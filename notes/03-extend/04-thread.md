# Thread

## basic

#### 

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


// 对比


程序: 静态的代码

进程: 正在运行的静态代码

线程: 正在运行的静态的代码中 处理不同事物的操作               // 操作系统级别

    - 单线程: 一个事物处理完, 才可以处理下一个事物
    
    - 多线程: 可以同时处理多个事物


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


程序

    - 主线程
    
    - 守护线程
    
    - 子线程
    
    - ...


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

## update status of thread

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


    new();       start();     CPU.run();   wait();          exception/over

    创建线程 ---> 就绪状态 ---> 执行状态 ---> 等待/挂起状态 ---> 异常/结束状态
                    |                           |
                    + ------------------------- +
                    
                        notify / notifyAll


    Thread { sleep(); run(); start(); setPriority(); getPriority(); join(); }
    
    Object { wait(); notify(); notifyAll(); }


//-------------------------------------------------------------------------------------------------------------------//

/** thread usage **/

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


// method_01: extends Thread


    1) class Demo {}                                    // 创建一个类
    
    2) class Demo extends Thread {}                     // 必须继承 Thread 父类
    
    3) class Demo extend Thread {
        @overwrite 
        public void run() {}                            // 必须重写 run(); 方法
    }
    
    4) class TestDemo {                                 // 利用类的实例 的 start(); 方法开启线程
        public static void (String[] args) {
            Demo dm = new Demo();
            dm.start();                                 // start(); 方法源自 继承的 Thread 父类
        ]                                               // 调用后 CPU 会分配内存, 并调用重写的 run(); 方法开启该线程
    }


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


// method_02: implements Runnable


    1) class Demo {}                                    // 创建一个类
    
    2) class abstract Demo implements Runnable {}       // 必须实现 Runnable 接口

    3) class TestDemo {                                 // 利用类的实例 的 start(); 方法开启线程
        public static void (String[] args) {
            Demo dm = new Demo();
            Thread td = new Thread(dm);                 // 创建线程实例, 并传入实现了 Runnable 接口的类
            td.start();                                 // start(); 方法源自 继承的 Thread 父类
        }                                               // 调用后 CPU 会分配内存, 并调用重写的 run(); 方法开启该线程
    }


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

#### suspended

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * 所有线程都进入了 await(); 后, 形成了假死状态
 * 
 * 
 * 解决方法 notify(); | notifyAll();
 */


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

#### synchronized

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * synchronized
 * 
 * 
 * 线程锁: 在多线程并发时, 保证同一时间有且仅有一个线程连接
 */


//-------------------------------------------------------------------------------------------------------------------//


// lock class

public synchronized void Method() {}            // 当前方法执行时, 锁定调用该方法的对象


//- - - - - - - - - - - - - - - - - - - - - - - - -  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


// lock target( func | code block | ... )

public void Method() {

    synchronized(target) {                      // 调用时, 锁定指定的内容
        
        ...
    }
}


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

#### notify(); & notifyAll();

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * 唤醒线程
 * 
 * 
 * 
 */


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

#### setPriority(); & getPriority();

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * setPriority(int leve);       // 设置线程的优先级别
 * 
 * 
 * @leve: [1, 10]               // 优先级别, 数字越大级别越高，更加容易获取 CPU 分配的资源碎片
 */


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

#### join();

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * join();
 * 
 * 
 * 将两个并行的线程, 编程独立有序的线程
 */


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

#### reflect

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


                                        // reflect: 类描述抽象对象, 反射描述抽象的类

                                        + ----------------- +       public Class {              // 描述类本身
                                        |                   |
                                        |                   |           Field prop;             // 描述类中的属性
                                        |                   |           Method (){}             // 描述类中的方法
                                        |                   |
                                        |                   |           constructer (){}        // 描述类中的构造方法
                                        |                   |           Package (){}            // 描述类所属的包
                                        |                   |           Annotation (){}         // 描述类中的注解
                                        |                   |
                                        |                   |           ... ...
                                        + ----------------- +       }
                                                  +
                                                  |
                    + --------------------- + --- + -------------- + ------------------------ +
                    |                       |                      |                          |
              + --------- +           + --------- +           + --------- +             + --------- +
              |   Class   |           |   Class   |           |   Class   |             |    ...    |
              + --------- +           + --------- +           + --------- +             + --------- +
           + ------ + ------ +      + ------ + ------ +     + ------ + ------ +       + ------ + ------ +
           |        |        |      |        |        |     |        |        |       |        |        |
         member   member   member member   member   member member   member   member  member   member   member


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


1) 获取 Class


    Class cls = Class.forName(String name);

    Class cls = [className].class;

    Class cls = [classInstance].getClass();



    Class cls = [classInstance].getSuperClass();            // 获取父类的父类名

    String modifier = cls.getModifiers();                   // 获取修饰符

    String modifier = cls.getInterfaces();                  // 获取接口
    
    Object obj = cls.newInstance();                         // 创建类的实例


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


2) 





///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

#### sleep(); vs wait();

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


// sleep(); vs wait();


1) 来自不同的类

    Thread.sleep();     
    
    Object.await();


2) 调用

    Class.sleep();
    
    Object.await();


3) 理解

    .sleep();           // 哪个线程调用, 哪个线程等待
    
    .await();           // 访问对象的其他线程等待


4) 唤醒

    .sleep();           // 不需要其他
    
    .await();           // 需要其他调用 notify(); 唤醒


4) 锁

    .sleep();           // 不会释放 
    
    .await();           // 等待后释放


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

#### consumer mode

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


// 消费者模式


    1. 安全锁: 同一时间有切仅有一个线程连接
    
    2. 操作线程
    
        - wait();                           // 线程挂起
        
        - notify(); | notifyAll();          // 唤醒线程
    
    3. Thread members
    
        - sleep();                          // 线程睡眠
        
        - setPriority(); | getPriority();   // 设置/获取 线程级别


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

#### deadlock

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


                // 经典案例: 哲学家就餐

                       people_a
                + ------------------ +
                | \ 1            2 / |
                |                    |
       people_d |                    |  people_b
                |                    |
                | / 4            3 \ |
                + ------------------ +
                       people_c


                每个人吃饭需要 先拿起左手的筷子, 再拿起右手的筷子, 然后再吃饭
                ( 造成同一时间的争抢, 从而锁死, 无法正常进行 )
                
                
                // 解决方法
                
                    - 分别岔开每个线程开启的时间( sleep(time) );
                    
                    - 避免使用 公共对象
                

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```


