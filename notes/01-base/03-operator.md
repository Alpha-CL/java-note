# operator

#### directory

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


// 根据功能分类


- 算术运算: + - * / % ++ --

- 赋值运算: = += -= *= /= &=

- 关系运算: > >= < <= != ==

- 逻辑运算: & | ^ ! && ||

- 位运算: & | ^ ~ << >>  >>>


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


// 根据操作成员的数量分类


- 单目: !a

- 双目: a + b

- 三目: a > b ? res1 : res2;


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

### base

#### Binary

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * Binary           // 二进制
 * 
 * 
 * 
 */




///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

#### 

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * 
 * 
 * 
 * 
 */


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

### operation

#### arithmetic operation

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// arithmetic operation             // 算术运算

//-------------------------------------------------------------------------------------------------------------------//

// 算术运算 会保持 算术类型的特性

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


int x = 5; 
x / 2 = 2;          // 依然保持整数类型的特性( 省略小数位 )


//-------------------------------------------------------------------------------------------------------------------//

// ++ --

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


        int x = 1;                  int x = 1;
                         ===   
        x = x + 1;                  x = x++;


        |                                   |                       |                       |
        |                                   |                       |                       |
        |                                   |                       |   + -- step_01 -- +   |
        |                                   |                       |   |       1       |   |
        |                                   |                       |   + ------------- +   |
        |                                   |                       |                       |
        |   + -------- step_03 -------- +   |                       |                       |
        |   |         1 + 1 = 2         |   |                       |                       |
        |   + ------------------------- +   |                       |                       |
        |  /|                           |   |                       |                       |
        |   |      + - step_02- +       |/  |                       |                       |
        |   + <--- |     1      | <---- +   |                       |                       |
        |          + ---------- +           |                       |                       |
        |                                   |                       |                       |
        + --------------------------------- + --------------------- + --------------------- +
                    stack                              heap                   fn zone


        * 算术运算 优先级大于 赋值运算


        - step_01: 在 栈 中开辟一个空间，用于存储方法区中的值
        
        - step_02: 在每次做值交换时，会产生一个 "临时的副本备份空间( 避免变量丢失或更改 )"
                   ( 备份空间中的值赋用于赋值 )
        - step_03: 
        
            ++ 在变量之前: 先自增，后备份
                                            ==> 计算完成后，再将结果赋值给原变量空间
            ++ 在变量之后: 先备份，后自增


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


int a = 1;
a = a++;

a ?             // 1


1. 将变量 a 的值 复制一份 作为 临时使用的副本空间

2. 将 a 的值自增 1

3. 将 临时使用的副本空间 复制给 a                  // 重点


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


int a = 1;
for(int i = i; i <= 100; i++) {
    a = a++;
}

a ?             // 1


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


int m = 1;
int n = 2;
int sum = m++ + ++n - n-- - --m + n++ - ++m;

m ?             // 0
n ?             // 1
sum ?           // 2


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

#### assignment operation

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * assignment operation         // 赋值运算
 * 
 * 
 * 将等号右边的内容 赋值到 等号左边的变量空间中
 */


//-------------------------------------------------------------------------------------------------------------------//


x ++;   ==   x += 1;


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


int x = 1;

x += 1;
x += num;


//-------------------------------------------------------------------------------------------------------------------//


byte x = 1;
x += 2;                 // err: int 转换为 byte 类型可能会有损失

x = (byte)(x + 2);      // 赋值时: 3( 32bit ) 存储到 8bit 中所以会报错( 需要强制类型转换 )


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


// 从变量空间中取出 x

x -> 1 -> 8 bit         // 00000001

// 从常量区中取出 2

2 -> 32 bit             // 00000000 00000000 00000000 00000010


// 1 + 2
00000001 + 00000000 00000000 00000000 00000010


// 转换为 二进制相加
00000000 00000000 00000000 00000001             // + 运算符 自动类型提升( 8bit -> 32bit )
00000000 00000000 00000000 00000010
00000000 00000000 00000000 00000011             // 3


// 等号运算符赋值时，会检查等号运算符右侧是 "值/表达式"

    1) 值: 则运算时自动转换后再运算

    2) 表达式: 无法判断表示表达式的返回值 需要'强制类型转换' 

        - 赋值时: 3( 32bit ) 存储到 8bit 中所以会报错( 需要强制类型转换 )


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

#### << >>

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


// <<


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


//-------------------------------------------------------------------------------------------------------------------//


// 2*8 最有效率的计算方式                    // 位移的性能大于数学运算

    1) 都转换为 2进制 后进行乘法运算, 再转换为 10进制
    
    2) 利用位运算 每移动一位代表 2的n次幂, 再转换为 10进制
    
        2<<3 === 2*(2的3幂)


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

#### variable exchange

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


// 易于理解, 但产生了新的变量, 浪费了内存空间

int a = 1,
    b = 2,
 temp = a;
 
 a = b;
 b = temp;
 
 System.out.printIn(a);     // 2
 System.out.printIn(b);     // 1


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


// 省略了新的空间, 但可能会产生越界( 存储的值超过了当前变量单位的空间范围 )

int a = 1,
    b = 2;
    
    a = a + b;              // a(sum) = a + b;
    b = a - b;              // b = sum - b => a
    a = a - b;              // a = sum - b => b
 
System.out.printIn(a);      // 2
System.out.printIn(b);      // 1


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


// 一个数字易或同一个数字两次, 值不会发生变化, 相较于上一种方式降低了越界的部分风险( 存储的值超过了当前变量单位的空间范围 )

int a = 1,
    b = 2;
    
    a = a ^ b;              // 
    b = a ^ b;              // 
    a = a ^ b;              // 

System.out.printIn(a);      // 2
System.out.printIn(b);      // 1


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

#### Scanner

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * Scanner              // 引用类型
 * 
 * 
 * 内置类 public final class Scanner
 */

import java.util.Scanner;                   // 使用之前必须引用

Scanner input = new Scanner();              // 对象


//-------------------------------------------------------------------------------------------------------------------//




import java.util.Scanner;

public class StudyEnglish {
    
    public static void main(String[]args) {
        
        Scanner input = new Scanner();
        
        int day = input.nextInt();
        
        if(day === 1) {
        
            System.out.printIn('monday');
            
        } else if
    }
}



///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

#### single  

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


        + ------------------------- + --------------------------------- + ----------------------------- +
        |                           |                                   |                               |
        |                           |                                   |                               |
        |                           |                                   |                               |
        |                           |                                   |                               |
        |                           |                                   |                               |
        |                           |                                   |                               |
        |                           |                                   |                               |
        |                           |                                   |                               |
        |                           |                                   |                               |
        + ------------------------- + --------------------------------- + ----------------------------- +


//-------------------------------------------------------------------------------------------------------------------//


int x = 1;

int y = x++; vs int y = ++x;            // ++ 在前: 先计算，再拷贝
                                        // ++ 在后: 先拷贝，再计算

x = ?
y = ?


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


// 计算过程分析


1) 将 x 变量空间的内容 提取到 常量区用于计算

2) 在做值交换时，会先生成一个临时使用的副本

3) 根据运算符计算

    * ++ 在前: 先备份，再自增
    
    * ++ 在后: 先自增，再备份

4) 赋值( 赋值后 销毁临时使用的副本 )


//-------------------------------------------------------------------------------------------------------------------//


int a = 1;

a = a++;

a ?                 // 1


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//



//-------------------------------------------------------------------------------------------------------------------//


int a = 1;

for(int i = 1; i <=  100; i++) {

    a = a++;
}

a ?                 // 1


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


虽然循环执行了 100 次，但是每一次循环中
因为 ++ 在后，每次都是赋予备份中的值 1


//-------------------------------------------------------------------------------------------------------------------//


int m = 1;
int n = 2;

int sum = m++ + ++n - n-- - --m + n-- - --m;

m?
n?
sum?

//-------------------------------------------------------------------------------------------------------------------//





///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

#### assignment

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * 赋值运算
 * 
 * 
 * 1) 自动类型提升:
 * 
 * 2) 
 */


//-------------------------------------------------------------------------------------------------------------------//


// 赋值运算赋右侧为 值

int x = 1;                      // 空间不同时赋值符号自动转化
x += 2;                         // // 空间不同时赋值符号自动转化
x = x + 2;                      // 自动类型提升


//-------------------------------------------------------------------------------------------------------------------//


// 赋值运算符右侧为 表达式

byte x = 1;                     // 空间不同时赋值符号自动转化
x += 2;                         // 空间不同时赋值符号自动转化
x = x + 2;                      // 空间不同时赋值符号无法判断右侧表达式
                                // 编译错误: 从 int 类型转换为 byte 类型可能有损失


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

#### logic

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// 逻辑运算符

//-------------------------------------------------------------------------------------------------------------------//


&           // 并且

[condition1] & [condition2]         // 同时满足 条件1 和 条件2


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


&&          // 短路与

[condition1] && [condition2]

若 条件1为真 则判断 条件2 是否为真
若 条件2为假，则直接返回结果( 不判断条件2 )


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


& vs &&

    有且仅当 条件1 为假时，&& 比 & 性能较好

    &: 可以当作 逻辑运算符 + 位运算符, &&: 只能被当作 逻辑运算符

    & 前后两个条件都是 true, 最终结果就是 true, && 当前面的条件是 false 时直接返回 false


//-------------------------------------------------------------------------------------------------------------------//


|           // 或者

[condition1] & [condition2]         // 条件1 或 条件2 任意满足其一即可


//-------------------------------------------------------------------------------------------------------------------//



^           // 异

[condition1] & [condition2]         // 条件1 与 条件2 的结果 必须相反


//-------------------------------------------------------------------------------------------------------------------//


!           // 非

![condition]                        // 获取条件相反的结果


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// 位运算

//-------------------------------------------------------------------------------------------------------------------//





///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

#### double

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * 
 * 
 * 
 * 
 */



///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

#### three

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * 
 * 
 * 
 * 
 */


statement ? value1 : value2;


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

