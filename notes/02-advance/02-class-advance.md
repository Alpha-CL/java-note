# 

## class relation

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


// class relation


A is B          // 继承 extend
A has B         // 包含 include
A use B         // 依赖 rely


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

#### this & super

``` javascript   
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



this & super 都是代替 对象

this & super 都可以调用一般的成员( 方法之间可以来回调用, 编译时好用, 执行时需要注意 StackOverflowError )

this & super 都可以调用构造方法, 但只能放在 另一个构造方法的第一行( 不能同时出现 ) 

    fatherClass { this(); ) 
    sonClass { super(); }


//-------------------------------------------------------------------------------------------------------------------//


// this: 指向当前类


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


// super: 指向父类


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

#### module

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


// package: 引入包


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


// import: 引入类


//-------------------------------------------------------------------------------------------------------------------//


// package vs import

package 和 import 同时出现, 先写 package 后写 import

package 只能有一个, import 可以有多个


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```


#### extend

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * extends
 * 
 * 
 * 
 */

子类 通过 extends 关键字继承 来自父类的 成员( 属性 & 方法 )

子类继承父类的成员后, 仍然可以创建自己的成员

所有类默认继承 Object, 使用 extends 关键字后, 则继承指定父类( 所有类都直接或间接的继承 Object )
( Object 没有 父类 )


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


// 以下情况不算继承, 更像是 钩子函数


    1. 构造方法: 严格意义上不算子类继承
    
        父类的构造方法 仅在 子类调用构造方法时 默认调用


    2. 程序块: 严格意义上不算子类继承
    
        程序块子类不能直接掉用, 子类执行构造方法之前
        
        默认调用父类的构造方法, 父类构造方法之前自动执行父类的块


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

#### include

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * 
 * 
 * 
 * 
 */


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

#### rely

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * 
 * 
 * 
 * 
 */


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

#### power_modifier

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * 权限修饰符 
 * 
 * 
 * 
 */


public > final > static > abstract



///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

#### override vs overload

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


// override( 重写 ) vs overload( 重载 )

    - 方法重写: 子类 重写 父类的方法
    
    - 方法重载: 类中 同名方法 重载 之前定义的方法


//-------------------------------------------------------------------------------------------------------------------//


// 权限

    - override: 子类 可以大于 父类
    
    - overload: 无要求


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


// 特征

    - override: 
    
        * final: 父类中该方法的描述符是 final, 则 子类不能重写
        
        * static:  父类中该方法的描述符是 static, 则 子类中不存在该成员
        
        * abstract:  父类中该方法的描述符是 static, 则 子类必须重写
        
        ( 子类是具体必须重写, 否则子类是抽象类, 可以不重写 )
    
    - overload: 无要求


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


// 返回值

    - override: 子类可以小于父类
    
    - overload: 无要求

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


// 名字

    - override: 子类 重写 父类的方法, 名字必须相同
    
    - overload: 利用同名方法重载 同一个类中之前定义的方法


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


// 参数

    - override: 子类与父亲类 参数必须一致
    
    - overload: 每个方法的参数( 个数, 类型, 顺序 )必须不一致


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


// 异常: 编译时 & 运行时

    - override: 如果父类方法抛出运行时异常, 则 子类可以不予理会
                如果父类放发抛出编译时异常, 子类抛出异常的个数 小于等于 父类
                                        子类抛出异常的类型 小于 父类
                
    - overload: 


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


// 方法体

    - override: 子类方法内容 与 父类不一致
    
    - overload: 每个重载方法执行过程 都不一致


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```






