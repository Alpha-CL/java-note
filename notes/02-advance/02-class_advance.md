# 

## Modifier

#### power_modifier

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


public > protected > default unwrite > private                        ( 不能修饰程序块 )

    * 修饰 class 的修饰符: 有切仅有 public, default unwrite              ( public & default-unwrite 为默认值可以不写 )
    

    | <------- 修饰符 ------> |        <------- 是否能访问 -------> |

      修饰符             描述           同一个类    同一个包    可继承
    
    - public            公共的            √          √         √       ( 修饰 class 时的默认修饰符 ) 

    - protected         保护的            √          √         √       ( 仅子对象在子类范围内 )

    - default-unwrite   默认的            √          √

    - private           私有的            √


//-------------------------------------------------------------------------------------------------------------------//


// public: 默认修饰符

同一个文件中虽然可以书写多个类

    但编译后文件名无法和多个类名对应

    同一个文件中 有且仅有一个类可以被 public 标记


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


// protected


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


// default unwrite


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


// private

    同一个 package 中, private 修饰的成员仅可在当前 class 中使用


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

#### feature_modifier.feature_modifier_final

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


final               // 最终的，不可改变的

static              // 静态的

abstract            // 抽象的

native              // 本地的

*transient          // 短暂的

*synchronized       // 同步的

*volatile           // 不稳定的


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

#### final

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// final: 最终的, 不可变的

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//
    
    
final variable          // 


    * 原始值
    
        - 声明即赋值: 赋值后即不可再次改变
        
        - 先声明, 后赋值: 赋值后即不可再次改变
    
    
    * 引用值: 地址不可改变           // 引用值中的 内容可改变

    
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


final prop              // 属性修饰必须赋初始值, 否则会报错
                          ( 因属性初始值是 class 赋予的, 若无赋初始值, 则后续无法再次改变 class 赋予的初始值 ) 

    * 原始值
    
        - 必须声明即赋值: 赋值后即不可再次改变
        
        - 不可以先声明, 后赋值: 
    
    
    * 引用值: 地址不可改变           // 引用值中的 内容可改变
    
    
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//
    
    
final method            // 

    - 无法被子类重写


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//
    
    
final class             //

    - 无法被继承


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

#### static

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * static prop, method, block_code, inner-class 
 * 
 * 
 * 可以修饰: 属性, 方法, 代码块, 内部类
 */


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


1) 静态元素在类加载时即初始化

2) "func zone" 中每个类都对应一个 静态方法区( static zone )          // 与其他类不共用, 不冲突

3) 每个类对应的 "静态成员" 仅在该类加载时加载一次, 并且该类和类中的成员共享这些 "静态成员"

    - 未创建实例时, 依然可以通过 类名调用 静态成员
    
4) 静态方法中

    - 不可以方法其他 "非静态成员"
    
    - 不可以使用 [ this -> class-instance ] & [ super -> father-class ]
               ( static member -> class )


//-------------------------------------------------------------------------------------------------------------------//


                                                                                                * 此划分仅供理解

        +                           +                           +                           +
        |                           |                           |                           |
        |                           |                           | <--- constant zone ---->  |   常量区
        |                           |                           |                           |
        |                           |                           |                           |
        |                           |                           | <------ func zone ------> |   方法区
        |                           |                           |                           |
        |                           |                           |                           |
        |                           |                           | <----- static zone -----> |   静态区
        |                           |                           |                           |
        |                           |                           |                           |
        |                           |                           |     [ static member ]     |
        |                           |                           |                           |
        |                           |                           |                           |
        + ------------------------- + ------------------------- + ------------------------- +
                   stack                       heap                      func zone

        // 内存释放:

        * stack: 使用完即回收, 并释放内存
        
        * heap: 通过垃圾回收器回收, 并释放内存
        
        * func zone: "static zone" 无法被 "Garbage Collectioon( 垃圾回收器 )" 管理回收释放
        
            - static zone: 常驻内存, 无法被垃圾回收器回收


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

####

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * 
 * 
 * 
 * 
 */


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

####

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * 
 * 
 * 
 * 
 */


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

####

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * 
 * 
 * 
 * 
 */


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

## class relation

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


// class relation


A is B          // 继承 extend
A has B         // 包含 include
A use B         // 依赖 rely


耦合度: 继承 > 包含 > 依赖


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


// extends




//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//



// has-a( 包含关系：组合, 聚合, 关联  )

    组合      // 人和大脑, 人和心脏, 整体和部分的关系, 不可分割, 要出现都出现, 要灭亡都灭亡
    
    聚合      // 汽车和车轮, 电脑和主板, 整体和部分的关系, 创建时有可能是分开的
    
    关联      // 人有汽车, 人有电脑, 整体和部分的关系, 可以分割, 后来在一起

    * 一个类的属性可以用另一个类描述


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


// use-a( need-a )              依赖关系

    屠夫 杀 猪      // 屠夫类 可以做 杀猪 这件事
                    ( 临时组合在一起, 做完这件事即解散关系 )

    


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

#### this & super

``` javascript   
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



this & super 都是代替 对象

this & super 都可以调用一般的成员( 方法之间可以来回调用, 编译时好用, 执行时需要注意 StackOverflowError )

this & super 都可以调用构造方法, 但只能放在 另一个构造方法的第一行( 不能同时出现 ) 

    fatherClass { this(); ) 
    sonClass { super(); }


//-------------------------------------------------------------------------------------------------------------------//


// this: 指向当前类


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


// super: 指向父类


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

#### module

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


// package: 引入包


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


// import: 引入类


//-------------------------------------------------------------------------------------------------------------------//


// package vs import

    package 和 import 同时出现, 先写 package 后写 import

    package 只能有一个, import 可以有多个


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

#### extend

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * extends
 * 
 * 
 * 
 */

子类 通过 extends 关键字继承 来自父类的 成员( 属性 & 方法 )

子类继承父类的成员后, 仍然可以创建自己的成员

所有类默认继承 Object, 使用 extends 关键字后, 则继承指定父类( 所有类都直接或间接的继承 Object )
( Object 没有 父类 )


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


// 以下情况不算继承, 更像是 钩子函数


    1. 构造方法: 严格意义上不算子类继承
    
        父类的构造方法 仅在 子类调用构造方法时 默认调用


    2. 程序块: 严格意义上不算子类继承
    
        程序块子类不能直接掉用, 子类执行构造方法之前
        
        默认调用父类的构造方法, 父类构造方法之前自动执行父类的块


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

#### include

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * 
 * 
 * 
 * 
 */


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

#### rely

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * 
 * 
 * 
 * 
 */


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

#### power_modifier

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * 权限修饰符 
 * 
 * 
 * 
 */


public > final > static > abstract



///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

#### override vs overload

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


// override( 重写 ) vs overload( 重载 )

    - 方法重写: 子类 重写 父类的方法
    
    - 方法重载: 类中 同名方法 重载 之前定义的方法


//-------------------------------------------------------------------------------------------------------------------//


// 权限

    - override: 子类 可以大于 父类
    
    - overload: 无要求


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


// 特征

    - override: 
    
        * final: 父类中该方法的描述符是 final, 则 子类不能重写
        
        * static:  父类中该方法的描述符是 static, 则 子类中不存在该成员
        
        * abstract:  父类中该方法的描述符是 static, 则 子类必须重写
        
        ( 子类是具体必须重写, 否则子类是抽象类, 可以不重写 )
    
    - overload: 无要求


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


// 返回值

    - override: 子类可以小于父类
    
    - overload: 无要求

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


// 名字

    - override: 子类 重写 父类的方法, 名字必须相同
    
    - overload: 利用同名方法重载 同一个类中之前定义的方法


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


// 参数

    - override: 子类与父亲类 参数必须一致
    
    - overload: 每个方法的参数( 个数, 类型, 顺序 )必须不一致


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


// 异常: 编译时 & 运行时

    - override: 如果父类方法抛出运行时异常, 则 子类可以不予理会
                如果父类放发抛出编译时异常, 子类抛出异常的个数 小于等于 父类
                                        子类抛出异常的类型 小于 父类
                
    - overload: 


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


// 方法体

    - override: 子类方法内容 与 父类不一致
    
    - overload: 每个重载方法执行过程 都不一致


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```






