# class advance

## class src.array.src.relation

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


// class src.array.src.relation


A is B          // 继承 extend
A has B         // 包含 include
A use B         // 依赖 rely


耦合度: 继承 > 包含 > 依赖


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


// extends [fatherClass]


继承 父类


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//



// has-a( 包含关系：组合, 聚合, 关联  )

    组合      // 人和大脑, 人和心脏, 整体和部分的关系, 不可分割, 要出现都出现, 要灭亡都灭亡
    
    聚合      // 汽车和车轮, 电脑和主板, 整体和部分的关系, 创建时有可能是分开的
    
    关联      // 人有汽车, 人有电脑, 整体和部分的关系, 可以分割, 后来在一起

    * 一个类的属性可以用另一个类描述


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


// use-a( need-a )              依赖关系

    屠夫 杀 猪      // 屠夫类 可以做 杀猪 这件事
                    ( 临时组合在一起, 做完这件事即解散关系 )


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

#### this & super

``` javascript   
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



this & super 都是代替 对象

this & super 都可以调用一般的成员( 方法之间可以来回调用, 编译时好用, 执行时需要注意 StackOverflowError )

this & super 都可以调用构造方法, 但只能放在 另一个构造方法的第一行( 不能同时出现 ) 

    fatherClass { this(); ) 
    sonClass { super(); }


//-------------------------------------------------------------------------------------------------------------------//


this: 指向当前类


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


super: 指向父类


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

#### module

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


// package: 引入包


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


// import: 引入类


//-------------------------------------------------------------------------------------------------------------------//


// package vs import

    package 和 import 同时出现, 先写 package 后写 import

    package 只能有一个, import 可以有多个


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

#### extend

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * extends
 * 
 * 
 * 
 */

子类 通过 extends 关键字继承 来自父类的 成员( 属性 & 方法 )

子类继承父类的成员后, 仍然可以创建自己的成员

所有类默认继承 Object, 使用 extends 关键字后, 则继承指定父类( 所有类都直接或间接的继承 Object )
( Object 没有 父类 )


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


// 以下情况不算继承, 更像是 钩子函数


    1. 构造方法: 严格意义上不算子类继承
    
        父类的构造方法 仅在 子类调用构造方法时 默认调用


    2. 程序块: 严格意义上不算子类继承
    
        程序块子类不能直接掉用, 子类执行构造方法之前
        
        默认调用父类的构造方法, 父类构造方法之前自动执行父类的块


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

#### include

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * 
 * 
 * 
 * 
 */


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

#### rely

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * 
 * 
 * 
 * 
 */


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

## Modifier

#### src.array.src.power_modifier

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


public > protected > default unwrite > private                        ( 不能修饰程序块 )

    * 修饰 class 的修饰符: 有切仅有 public, default unwrite              ( public & default-unwrite 为默认值可以不写 )
    

    | <------- 修饰符 ------> |        <------- 是否能访问 -------> |

      修饰符             描述           同一个类    同一个包    可继承
    
    - public            公共的            √          √         √       ( 修饰 class 时的默认修饰符 ) 

    - protected         保护的            √          √         √       ( 仅子对象在子类范围内 )

    - default-unwrite   默认的            √          √

    - private           私有的            √


//-------------------------------------------------------------------------------------------------------------------//


// public: 默认修饰符

同一个文件中虽然可以书写多个类

    但编译后文件名无法和多个类名对应

    同一个文件中 有且仅有一个类可以被 public 标记


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


// protected


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


// default unwrite


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


// private

    同一个 package 中, private 修饰的成员仅可在当前 class 中使用


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

#### src.array.src.feature_modifier.feature_modifier_final

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


final               // 最终的，不可改变的

static              // 静态的

abstract            // 抽象的

native              // 本地的

*transient          // 短暂的

*synchronized       // 同步的

*volatile           // 不稳定的


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

#### final

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// final: 最终的, 不可变的

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//
    
    
final variable          // 


    * 原始值
    
        - 声明即赋值: 赋值后即不可再次改变
        
        - 先声明, 后赋值: 赋值后即不可再次改变
    
    
    * 引用值: 地址不可改变           // 引用值中的 内容可改变

    
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


final prop              // 属性修饰必须赋初始值, 否则会报错
                         ( 因属性初始值是 class 赋予的, 若无赋初始值, 则后续无法再次改变 class 赋予的初始值 ) 

    * 原始值
    
        - 必须声明即赋值: 赋值后即不可再次改变
        
        - 不可以先声明, 后赋值: 
    
    
    * 引用值: 地址不可改变           // 引用值中的 内容可改变
    
    
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//
    
    
final method            // 

    - 无法被子类重写


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//
    
    
final class             //

    - 无法被继承


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

#### static

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * static prop, method, block_code, inner-class 
 * 
 * 
 * 可以修饰: 属性, 方法, 代码块, 内部类
 */


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


1) 静态元素在类加载时即初始化

2) "func zone" 中每个类都对应一个 静态方法区( static zone )          // 与其他类不共用, 不冲突

3) 每个类对应的 "静态成员" 仅在该类加载时加载一次, 并且该类和类中的成员共享这些 "静态成员"

    - 未创建实例时, 依然可以通过 类名调用 静态成员
    
4) 静态方法中

    - 不可以方法其他 "非静态成员"
    
    - 不可以使用 [ this -> class-instance ] & [ super -> father-class ]
               ( static member -> class )


//-------------------------------------------------------------------------------------------------------------------//


                                                                                                * 此划分仅供理解

        +                           +                           +                           +
        |                           |                           |                           |
        |                           |                           |                           |
        |                           |                           | <--- constant zone -----> |   常量区
        |                           |                           |                           |
        |                           |                           |                           |
        |                           |                           | <------ func zone ------> |   方法区
        |                           |                           |                           |
        |                           |                           |                           |
        |                           |                           | <----- static zone -----> |   静态区
        |                           |                           |                           |
        |                           |                           |                           |
        |                           |                           |     [ static member ]     |
        |                           |                           |                           |
        |                           |                           |                           |
        + ------------------------- + ------------------------- + ------------------------- +
                   stack                       heap                      func zone

        // 内存释放: 对象空间没有任何指向视为垃圾

        * stack:        变量空间, 方法临时执行空间              // 从穿件开始执行完毕, 使用完即回收, 并释放内存
        
        * heap:         new 申请对象空间                      // 通过垃圾回收器回收, 并释放内存
        
        * func zone:    "static zone" 无法被 "Garbage Collectioon( 垃圾回收器 ) 管理/回收/释放"
        
            - static zone: 常驻内存, 有切仅有一份, 不回收        // 无法被垃圾回收器回收


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


// 内存释放: 对象空间没有任何指向视为垃圾

public class Person{}

public class Test {
    public Person p = new Person();
}

Test test = new Test();
Person p = test.p


// 必须切段一切引用指向才会视为垃圾
p = null;
test.p = null;


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


// src.array.src.error

    - 堆内存溢出: OutOfMemoryError
    
    - 栈内存溢出: StackOverflowError


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

#### native

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * native
 * 
 * 
 * java 源码中 native 已经是用户可见的最底层了
 * ( 其内部可能调用 C, C++ 执行内存操作 )
 */


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

#### abstract

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * abstract             // 抽象
 * 
 * 
 * 可以修饰: 类, 方法
 */


//-------------------------------------------------------------------------------------------------------------------//

/** abstract-method **/

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


// abstract-method vs native-method: 两者书写一样, 但意义不同

    - abstract-method
    
        只有方法结构, 没有方法体( 一种抽象的思想 )
            
    - native-method
    
        只有方法结构, 没有方法体( 但依然会有底层 C, C++ 处理内存 )


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//

/** abstract-class **/

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


/**
 * abstract-class
 * 
 * 
 *      - 抽象类中可以没有抽象方法, 全部都是具体成员              // abstract-class
 * 
 *      - 抽象类中没有具体成员, 全部都是抽象方法                  // interface
 * 
 */


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

#### interface

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * interface                // 接口中仅含有抽象的成员
 * 
 *      - prop
 *      - method
 * 
 * 接口中不能包含任何具体化的成员, 仅包含抽象成员
 * 仅通过子类 多实现( implements ) 将接口中的抽象成员具体化
 *
 ** 接口更像是将用于约束子类的共同特征, 再由继承的子类分别以不同的方式实现这些特征的
 */


1) 接口不能继承 其他类( 抽象类, 具体类 )

2) 接口可以 直接多继承 接口

3) 抽象类 可以直接多实现 接口       // public abstract class A implements B, C {}

4) 具体类 不可以 直接多实现 接口( 必须将接口中的抽象方法具体化, 否则该子类也需变成 抽象类 )


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


// interface


    - prop              √       // 仅含有 public static final [prop];
    
    - method            √       // 仅含有 public abstract [method] ();
                                // 1.8 version 后可以使用 default 修饰 具体方法
    
    - block-code        x       // 没有 一般块, 静态块
                                ( 接口中仅含有抽象的成员 )
    
    - construct-func    x       // 没有构造方法


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

## modifier

#### src.array.src.power_modifier

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * 权限修饰符 
 * 
 * 
 */


public > final > static > abstract


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

#### override vs overload

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


// override( 重写 ) vs overload( 重载 )

    - 方法重写: 子类 重写 父类的方法
    
    - 方法重载: 类中 同名方法 重载 之前定义的方法


//-------------------------------------------------------------------------------------------------------------------//


// 权限

    - override: 子类 可以大于 父类
    
    - overload: 无要求


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


// 特征

    - override: 
    
        * final: 父类中该方法的描述符是 final, 则 子类不能重写
        
        * static:  父类中该方法的描述符是 static, 则 子类中不存在该成员
        
        * abstract:  父类中该方法的描述符是 static, 则 子类必须重写
        
        ( 子类是具体必须重写, 否则子类是抽象类, 可以不重写 )
    
    - overload: 无要求


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


// 返回值

    - override: 子类可以小于父类
    
    - overload: 无要求

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


// 名字

    - override: 子类 重写 父类的方法, 名字必须相同
    
    - overload: 利用同名方法重载 同一个类中之前定义的方法


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


// 参数

    - override: 子类与父亲类 参数必须一致
    
    - overload: 每个方法的参数( 个数, 类型, 顺序 )必须不一致


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


// 异常: 编译时 & 运行时

    - override: 如果父类方法抛出运行时异常, 则 子类可以不予理会
                如果父类放发抛出编译时异常, 子类抛出异常的个数 小于等于 父类
                                        子类抛出异常的类型 小于 父类
                
    - overload: 


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


// 方法体

    - override: 子类方法内容 与 父类不一致
    
    - overload: 每个重载方法执行过程 都不一致


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

## inner Class

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * 内部类
 * 
 * 
 * java 中可以将一个 类 定义在 另一个类 内部        // 与该类中不同成员处于不同的层级
 *      - 方法
 *      - 方法内部
 *      - 块
 */

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


- 成员内部类: 将类定义直接定义在另一个类的内部, 与属性和方法处于同一个层级


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


- 局部内部类: 将 类 定义在 方法/块 内部, 作为成员的内部结构


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


- 匿名内部类:                // 通常用于 抽象类 & 接口 子类的实现
                            // 具体类也可以有匿名类

    成员匿名内部类
    
    局部匿名内部类


// example

public interface Test {
    public void test();
}

Test t = new Test() {               // 匿名类: 省略一个类文件( 仅有类的方法体, 无修饰符，无构造方法 )

    public void test() {
    
    }
};


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


- 静态内部类: 不需要外部类

    静态成员内部


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```
